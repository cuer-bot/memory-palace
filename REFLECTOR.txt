// SPECTRA REFLECTION OF bridge.js

const http = require('http');
const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

const REPO_ROOT = __dirname;
const PORT = 3005;

// 1x1 transparent PNG for browser feedback
const TRANSPARENT_PNG = Buffer.from(
    '89504e470d0a1a0a0000000d49484452000000010000000108060000001f15c4890000000b49444154789c6360000200000500017a5eab3f0000000049454e44ae426082',
    'hex'
);

function log(msg) {
    const ts = new Date().toISOString().split('T')[1].split('.')[0];
    console.log(`[${ts}] [SPECTRA] ${msg}`);
}

function safePath(p) {
    if (!p) throw new Error('Missing file path');
    const normalized = path.normalize(p).replace(/^(\.\.(\/|\\|$))+/, '');
    return normalized;
}

const server = http.createServer((req, res) => {
    res.setHeader('Access-Control-Allow-Origin', '*');
    
    // Use WHATWG URL API
    const reqUrl = new URL(req.url, `http://${req.headers.host}`);
    const pathname = reqUrl.pathname;
    const query = Object.fromEntries(reqUrl.searchParams);

    const sendImg = () => {
        res.writeHead(200, { 'Content-Type': 'image/png', 'Cache-Control': 'no-store' });
        res.end(TRANSPARENT_PNG);
    };

    const sendText = (txt) => {
        res.writeHead(200, { 'Content-Type': 'text/plain; charset=utf-8' });
        res.end(txt);
    };

    const sendError = (err) => {
        log(`‚ùå Error: ${err.message}`);
        res.writeHead(500);
        res.end(err.message);
    };

    if (req.method === 'GET') {
        try {
            if (pathname === '/read') {
                const file = safePath(query.file);
                const fullPath = path.join(REPO_ROOT, file);
                if (fs.existsSync(fullPath)) {
                    sendText(fs.readFileSync(fullPath, 'utf8'));
                } else {
                    res.writeHead(404);
                    res.end(`File not found: ${file}`);
                }
            } 
            else if (pathname === '/status') {
                const status = execSync('git status --porcelain', { cwd: REPO_ROOT }).toString();
                sendText(status || 'Clean working tree');
            }
            else if (pathname === '/patch') {
                const file = safePath(query.file);
                const diff = Buffer.from(query.data, 'base64').toString('utf8');
                fs.writeFileSync('cuer_temp.patch', diff);
                try {
                    execSync(`patch -u ${file} -i cuer_temp.patch`, { cwd: REPO_ROOT });
                    log(`üí† Patched: ${file}`);
                } finally {
                    if (fs.existsSync('cuer_temp.patch')) fs.unlinkSync('cuer_temp.patch');
                }
                sendImg();
            }
            else if (pathname === '/stage') {
                const file = safePath(query.file);
                execSync(`git add ${file}`, { cwd: REPO_ROOT });
                log(`üîπ Staged: ${file}`);
                sendImg();
            }
            else if (pathname === '/commit') {
                const msg = query.message || 'SPECTRA: Automated update';
                try {
                    execSync(`git commit -m "${msg}"`, { cwd: REPO_ROOT });
                    log(`‚úÖ Committed: "${msg}"`);
                } catch (e) {
                    if (!e.message.includes('nothing to commit')) throw e;
                }
                sendImg();
            }
            else if (pathname === '/push') {
                log('üöÄ Pushing to origin...');
                execSync('git push origin HEAD', { cwd: REPO_ROOT });
                log('‚òÅÔ∏è Push complete.');
                sendImg();
            }
            else if (pathname === '/reflect') {
                // Read a file and push its content to REFLECTOR.txt on GitHub
                const file = safePath(query.file);
                const fullPath = path.join(REPO_ROOT, file);
                const content = fs.readFileSync(fullPath, 'utf8');
                fs.writeFileSync('REFLECTOR.txt', `// SPECTRA REFLECTION OF ${file}\n\n${content}`);
                execSync('git add REFLECTOR.txt && git commit -m "SPECTRA: Reflecting ' + file + '" && git push origin HEAD', { cwd: REPO_ROOT });
                log(`üì° Reflected ${file} to GitHub.`);
                sendImg();
            }
            else if (pathname === '/capsule-reflect') {
                // Fetch a memory from m.cuer.ai and push to REFLECTOR.txt
                const id = query.id;
                const url = `https://m.cuer.ai/q/${id}`;
                log(`üì° Proxying capsule ${id}...`);
                execSync(`curl -s ${url} -o REFLECTOR.txt`, { cwd: REPO_ROOT });
                execSync('git add REFLECTOR.txt && git commit -m "SPECTRA: Reflecting capsule ' + id + '" && git push origin HEAD', { cwd: REPO_ROOT });
                sendImg();
            }
            else {
                res.writeHead(404);
                res.end('Unknown endpoint');
            }
        } catch (e) {
            sendError(e);
        }
    }
});

server.listen(PORT, '127.0.0.1', () => {
    console.log(`\n‚ùñ OPTICAL DAEMON v4 (REFLECTOR) ONLINE ‚ùñ`);
    console.log(`Listening on http://127.0.0.1:${PORT}`);
    console.log(`Ready for autonomous read/write operations.`);
});